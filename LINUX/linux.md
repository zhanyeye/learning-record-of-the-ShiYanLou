linux 

###### 实验1 Linux 系统简介

安装程序

```shell
sudo apt-get update
sudo apt-get install <name>
```

##### 实验2 基本概念及操作

Linux 用户管理

linux 是一个可以实现多用户登录的操作系统，比如 A 和 B 可以同时登陆通一台主机，他们共享主机资源，也分别有自己的用户空间，存放各自文件。由于Linux 的**用户管理**和**权限机制**，不同用户之间不可以轻易查看、修改彼此文件。

###### 快捷键

| 按键     | 作用                     |
| -------- | ------------------------ |
| ctrl + a | 光标移至输入行头 Home    |
| ctrl + e | 光标移至输入行尾 End     |
| ctrl + k | 删除从光标所在位置到行尾 |



历史输入命令： `pg up   ↑`

###### Shell 常用通配符

| 字符                    | 含义                                           |
| ----------------------- | ---------------------------------------------- |
| *                       | 匹配 0 或多个字符                              |
| ?                       | 匹配任意一个字符                               |
| [list]                  | 匹配 list 中的任意单一字符                     |
| [^list]                 | 匹配 list 中的任意单一字符以外的字符           |
| [c1-c2]                 | 匹配 c1-c2 中的任意单一字符，如：`[0-9]`,[a-z] |
| {string1, string2, ...} | 匹配 string1 或 string2 (...) 其一**字符串**   |
| {c1..c2}                | 匹配 c1-c2 中全部字符 如{1..10}                |

一次创建多个文件：比如： "love_1_linux.txt, love_2_linux.txt, ... love_10_linux.txt"

```shell
$ touch love_{1..10}_shiyanlou.txt
```



###### 获取帮助

**man** 

 是 `Manual pages` 的缩写， 调用手册页, 分为8个区段, 分别从 1~ 8 来标识（查看相应区段，在man 后面加上相应数字即可）

1 ：一般命令,   2 ：系统调用, 3 ：库函数，涵盖C标准函数库

```
$ man <command_name>
```

在 `man` 中使用搜索：`/<你要搜的关键字>`

`n` 切换下一个关键字;  `shift + n`为上一个关键字

`Space` 翻页  `Enter` 向下滚动一行 或 `K,J`  (vim)

`q` 退出

**-- help 参数**

```shell
$ ls --help
```



##### 实验3 用户及文件权限管理

###### 查看用户

```shell
$ who am i
$ who mom likes
```

###### 创建用户

`su <user>`  切换到用户 user

`sudo <cmd> `  以特权级别运行 cmd 命令, 需要当前用户属于 sudo 组

`sudo - <user>`  切换用户，同时改变环境变量  -> 好像和 `sudo -l <user>` 一样

`sudo addusesr <username>`   新建用户

###### 用户组

`groups <user>`  查看用户属于哪个用户组

新建用户如不指定用户组，默认创建一个与用户名相同的用户组

**将用户添加到用户组**

```shell
$ sudo usermod -G <groupname> <username>   
```

**删除用户**

```shell
$ sudo deluser <username> --remove-home
```



###### linux 文件权限

**查看文件权限**

使用较长格式列出文件

```shell
$ ls -l
```

![](https://doc.shiyanlou.com/linux_base/3-9.png/wm)

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/img/img/20190709133321.png)

**变更文件所有者**

将文件的的所有者设为user, 用户组设置为group

```shell
$ chown user[:group] file...
```

**修改文件权限**

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/img/img/20190709135026.png)

+ 二进制数字表示

  ```shell
  $ chmod --- <file name>    --- 分别代表
  example:
  $ chmod 600 test.text  只有拥有者有读写能力
  ```

+ 加减赋值操作

  ```shell
  $ chmod [g,o,u][+,-][r,w,x] <file name> 
  example:
  $ chmod go-rw iphone6   
  g, o, u  表示 group, others, user
  +, - 表示增加和去掉相应的权限
  ```

  

##### 实验4 Linux 目录结构及文件基本操作

###### FHS 标准

![](https://doc.shiyanlou.com/linux_base/4-1.png/wm)

+ 输入命令时：连续2次 `tab` 会显示所有可能的情况

###### 文件操作

新建空白文件：**touch**

+ 主要用来更改已有文件的时间戳（如：最近访问时间，和修改时间）
+ 若只指定一个文件名的，则创建一个空白文件（不会覆盖已有同名文件）

新建目录：**mkdir**

+ 可以创建一个空目录，也可以同时指定创建目录的权限属性
+  `-p`参数： 如果不存在父目录：同时创建一个多级目录

复制文件：**cp** 

`cp [options] source dest `

+ `-r` 参数：递归复制，复制目录时使用

删除文件：**rm**

+ 强制删除 `rm -f <file name>`
+ 删除目录（递归删除）`rm -r <filename>`

移动文件和重命名：**mv**

+ 移动文件：`mv 原目录文件 目的目录`
+ 重命名文件：`mv 旧的文件名 新的文件名`
+ 批量重命名使用： `rename`

###### 查看文件

**cat, tac**

打印文件内容到标准输出，cat 正序显示，tac 倒序

+ `-n` 显示行号 

**nl** 添加行号并打印

**more** 和 **less** 分页查看文件

+ Enter 向下一行
+ Space 下滚动一屏
+ h 帮助，q 退出

**head** 和 **tail** 命令 

+ 默认看前10行或后10行，可以指定行数，－n 1(只看１行)

查看文件类型：**file**



##### 实验5 环境变量与文件查找

shell中创建一个变量

`declare tmp`  其实也可以不用 declare 预声明一个变量，直接即用即创建

`tmp=shiyanlou`

 读取变量的值`echo`

```
$ echo $tmp
```

$ 符号，用于表示引用一个变量的值

###### 环境变量

> 环境变量的作用域比自定义变量的要大，如 Shell 的环境变量作用于自身和它的子进程。在所有的 UNIX 和类 UNIX 系统中，每个进程都有其各自的环境变量设置，且默认情况下，当一个进程被创建时，除了创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。

通常我们会涉及到的变量类型有三种：

- 当前 Shell 进程私有用户自定义变量，如上面我们创建的 tmp 变量，只在当前 Shell 中有效。
- Shell 本身内建的变量。
- 从自定义变量导出的环境变量。

也有三个与上述三种环境变量相关的命令：`set`，`env`，`export`。这三个命令很相似，都是用于打印环境变量信息，区别在于涉及的变量范围不同。详见下表：

| 命 令    | 说 明                                                        |
| -------- | ------------------------------------------------------------ |
| `set`    | 显示当前 Shell 所有变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量。 |
| `env`    | 显示与当前用户相关的环境变量; 还可以让命令在指定环境中运行。 |
| `export` | 显示从 Shell 中导出成环境变量的变量; 也能通过它将自定义变量导出为环境变量。 |

 关于哪些变量是环境变量，可以简单地理解成在当前进程的子进程有效则为环境变量，否则不是（有些人也将所有变量统称为环境变量，只是以全局环境变量和局部环境变量进行区分，我们只要理解它们的实质区别即可）。我们这里用 `export` 命令来体会一下，先在 Shell 中设置一个变量 `temp=shiyanlou`，然后再新创建一个子 Shell 查看 `temp` 变量的值：

 ![](https://doc.shiyanlou.com/document-uid735639labid60timestamp1532339293501.png/wm)

**永久生效**

> 但是问题来了，当你关机后，或者关闭当前的 shell 之后，环境变量就没了啊。怎么才能让环境变量永久生效呢？

按变量的生存周期来划分，Linux 变量可分为两类：

1. 永久的：需要修改配置文件，变量永久生效；
2. 临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。

这里介绍两个重要文件 `/etc/bashrc`（有的 Linux 没有这个文件） 和 `/etc/profile` ，它们分别存放的是 shell 变量和环境变量。还有要注意区别的是每个用户目录下的一个隐藏文件：

```
.profile 可以用 ls -a 查看
cd /home/shiyanlou
ls -a 
```

这个 .profile 只对当前用户永久生效。而写在 `/etc/profile` 里面的是对所有用户永久生效，所以如果想要添加一个永久生效的环境变量，只需要打开 `/etc/profile`，在最后加上你想添加的环境变量就好啦。

###### 命令的查找路径与顺序

> 我们在 Shell 中输入一个命令，Shell 是怎么知道去哪找到这个命令然后执行的呢？这是通过环境变量 `PATH` 来进行搜索的，熟悉 Windows 的用户可能知道 Windows 中的也是有这么一个 PATH 环境变量。这个 `PATH` 里面就保存了 Shell 中执行的命令的搜索路径。
>
> 当我们在 Shell 中执行一个命令时，系统就会按照 PATH 中设定的路径按照顺序依次到目录中去查找，如果存在同名的命令，则执行先找到的那个。

**创建shell脚本**

```shell
$ cd /home/shiyanlou
$ touch hello_shell.sh
$ gedit hello_shell.sh
```

在脚本中添加如下内容，保存并退出（**注意不要省掉第一行，这不是注释，论坛有用户反映有语法错误，就是因为没有了第一行**）：

```shell
#!/bin/bash

for ((i=0; i<10; i++));do
    echo "hello shell"
done

exit 0
```

为文件添加可执行权限：

```shell
$ chmod 755 hello_shell.sh
```

执行脚本：

```shell
$ cd /home/shiyanlou
$ ./hello_shell.sh
```

如何做到像使用系统命令一样执行自己创建的脚本文件或者程序呢？那就要将命令所在路径添加到 `PATH` 环境变量了。

###### 添加自定义路径到“ PATH ”环境变量

 在前面我们应该注意到 `PATH` 里面的路径是以 `:` 作为分割符的，所以我们可以这样添加自定义路径：

```
$ PATH=$PATH:/home/shiyanlou/mybin
```

**注意这里一定要使用绝对路径。**

现在你就可以在任意目录执行那个命令了（注意需要去掉前面的 `./`）。你可能会意识到这样还并没有很好的解决问题，因为我给 PATH 环境变量追加了一个路径，它也只是在当前 Shell 有效，我一旦退出终端，再打开就会发现又失效了。有没有方法让添加的环境变量全局有效？或者每次启动 Shell 时自动执行上面添加自定义路径到 PATH 的命令？下面我们就来说说后一种方式——让它自动执行。

在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等等。zsh 的配置文件是 `.zshrc`，相应 Bash 的配置文件为 `.bashrc` 。它们在 `etc` 下还都有一个或多个全局的配置文件，不过我们一般只修改用户目录下的配置文件。

我们可以简单地使用下面命令直接添加内容到 `.zshrc` 中：

```
$ echo "PATH=$PATH:/home/shiyanlou/mybin" >> .zshrc
```

**上述命令中 >> 表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的 > 是以覆盖的方式重定向到一个文件中，使用的时候一定要注意分辨。在指定文件不存在的情况下都会创建新的文件。**

###### 修改和删除已有变量

 

**变量修改**

变量的修改有以下几种方式：

| 变量设置方式                   | 说明                                         |
| ------------------------------ | -------------------------------------------- |
| `${变量名#匹配字串}`           | 从头向后开始匹配，删除符合匹配字串的最短数据 |
| `${变量名##匹配字串}`          | 从头向后开始匹配，删除符合匹配字串的最长数据 |
| `${变量名%匹配字串}`           | 从尾向前开始匹配，删除符合匹配字串的最短数据 |
| `${变量名%%匹配字串}`          | 从尾向前开始匹配，删除符合匹配字串的最长数据 |
| `${变量名/旧的字串/新的字串}`  | 将符合旧字串的第一个字串替换为新的字串       |
| `${变量名//旧的字串/新的字串}` | 将符合旧字串的全部字串替换为新的字串         |

比如要修改我们前面添加到 PATH 的环境变量。为了避免操作失误导致命令找不到，我们先将 PATH 赋值给一个新的自定义变量 path：

```
$ path=$PATH
$ echo $path
$ path=${path%/home/shiyanlou/mybin}
# 或使用通配符,*表示任意多个任意字符
$ path=${path%*/mybin}
```

**变量删除**

可以使用 `unset` 命令删除一个环境变量：

```
$ unset temp
```



######  如何让环境变量立即生效

前面我们在 Shell 中修改了一个配置脚本文件之后（比如 zsh 的配置文件 home 目录下的 `.zshrc`），每次都要退出终端重新打开甚至重启主机之后其才能生效，很是麻烦，我们可以使用 `source` 命令来让其立即生效，如：

```
$ cd /home/shiyanlou
$ source .zshrc
```

`source` 命令还有一个别名就是 `.`，上面的命令如果替换成 `.` 的方式就该是：

```
$ . ./.zshrc
```

在使用`.`的时候，需要注意与表示当前路径的那个点区分开。

注意第一个点后面有一个空格，而且后面的文件必须指定完整的绝对或相对路径名，source 则不需要。

###### 搜索文件

 与搜索相关的命令常用的有 `whereis`，`which`，`find` 和 `locate` 。

- **whereis 简单快速**

  这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询。`whereis` 只能搜索**二进制文件**`-b`，**man 帮助文件**`-m`和**源代码文件**`-s`。

```
$ whereis who
$ whereis find
```

- **locate 快而全**

通过“ /var/lib/mlocate/mlocate.db ”数据库查找，不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 `updatedb` 命令更新一次，所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 `updatedb` 命令（在我们的环境中必须先执行一次该命令）。它可以用来查找指定目录下的不同文件类型，如查找 /etc 下所有以 sh 开头的文件：

```
$ sudo apt-get update
$ sudo apt-get install locate
$ locate /etc/sh
```

> **注意，它不只是在 /bin 目录下查找，还会自动递归子目录进行查找。**

查找 /usr/share/ 下所有 jpg 文件：

```
$ locate /usr/share/\*.jpg
```

> **注意要添加 \* 号前面的反斜杠转义，否则会无法找到。**

如果想只统计数目可以加上 `-c` 参数，`-i` 参数可以忽略大小写进行查找，whereis 的 `-b`、`-m`、`-s` 同样可以使用。

- **which 小而精**

`which` 本身是 Shell 内建的一个命令，我们通常使用 `which` 来确定是否安装了某个指定的软件，因为它只从 `PATH` 环境变量指定的路径中去搜索命令：

```
$ which man
```

- **find 精而细**

`find` 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。`find` 命令强大到，要把它讲明白至少需要单独好几节课程才行，我们这里只介绍一些常用的内容。

这条命令表示去 /etc/ 目录下面 ，搜索名字叫做 interfaces 的文件或者目录。这是 find 命令最常见的格式，千万记住 find 的第一个参数是要搜索的地方：

```
$ sudo find /etc/ -name interfaces
```

> **注意 find 命令的路径是作为第一个参数的， 基本命令格式为 `find [path][option] [action] `。**