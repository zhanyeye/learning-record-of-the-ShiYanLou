#### 数据结构

##### 线性表

###### 顺序存储

+ 随机访问(C语言中基于数组),即通过首地址和元素序号可以在O(1)的时间内找到指定的元素
+ 存储密度高,每个结点只存储数据元素。无需给表中元素花费空间建立它们之间的逻辑关系(因为物理位置相邻特性决定)
+ 相邻的元素物理上也相邻,所以插入和删除操作需要移动大量元素

要从内存中开辟一块连续的区域(数组)来存储数据

```c++
//存储结构
struct SqList {
    ElemType* data; //存储空间基地址
    int length;     //当前长度
    int max_size;   //当前分配表长大小
        
};

//初始化一个空线性表
bool InitList(SqList &L) {
    L.data = (ElemType*) malloc(sizeof(ElemType) * MAXSIZE);
    if (L.data == NULL) {
        return false;
    }
    L.length = 0;
    L.max_size = MAXSIZE;
    return true;
}
```

1. 插入

   > 在顺序表L的第i(1≤i≤L.length+1)个位置插入新元素e。如果i的输入不合法,则返回false,表示插入失败;否则,将顺序表的**第i个元素以及其后的所有元素右移一个位置,腾出一个空位置插入新元素e,顺序表长度增加1**,插入成功,返回true。

   算法思路:

   1. 判断i的值是否正确
   2. 判断表长是否超过数组长度
   3. 从后向前到第i个位置,分别将这些元素都向后移动一位
   4. 将该元素插入位置i 并修改表长

   ```c++
   bool ListInsert(SqList &L, int i, ElemType e) {
       if (i < 1 || i > L.length + 1) { //判断i的范围是否有效
           return false;
       }
       if (L.length >= L.max_size) { //判断存储空间是否以满
           return false;
       }
       for (int j = L.length; j >= i; j--) { //将第i个元素及其之后元素后移
           L.data[j] = L.data[j-1]; //将数组 j-1 向后移
   
       }
       L.data[i-1] = e; //在位置i出放入e,注意数组从0开始
       L.length++;
       return true;
   }
   ```

   最好情况:在表尾插入(即i=n+1),元素后移语句将不执行,时间复杂度为O(1)。
   最坏情况:在表头插入(即i=1),元素后移语句将执行n次,时间复杂度为O(n)。
   平均情况:假设pi(pi=1/(n+1) )是在第i个位置上插入一个结点的概率,则在长度为n的线性表中插入一个结点时所需移动结点的平均次数为

   ![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/deepin-pic/img20190722120816.png)

   $\frac{1}{n+1} * (n + ... + 0)$

   

2. 删除

   > 删除顺序表L中第i(1≤i≤L.length)个位置的元素,成功则返回true,并将被删除的元素用引用变量e返回,否则返回false。

   算法思路:

   1. 判断i的值是否正确
   2. 取删除的元素
   3. 将被删元素后面的所有元素都依次向前移动一位
   4. 修改表长

   ```c++
   bool ListDelete(SqList &L, int i, ElemType e) {
       if (i < 1 || i > L.length) { //判断范围是否有效
           return false;
       }
       e = L.data[i-1];   //保存将要被删除的元素
       for (int j = i; j < L.length; j++) { // 将第 i个位置之后的元素前移
           L.data[j-1] = L.data[j]; 
       }
       L.length--;
       return true;
   }
   ```

   最好情况:删除表尾元素(即i=n),无须移动元素,时间复杂度为O(1)。
   最坏情况:删除表头元素(即i=1),需要移动除第一个元素外的所有元素,时间复杂度为O(n)。
   平均情况:假设pi(pi=1/n)是删除第i个位置上结点的概率,则在长度为n的线性表中删除一个结点时所需移动结点的平均次数为

   ![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/deepin-pic/img20190722122755.png)

$\frac{1}{n}*(n-1 + ... + 0)$



###### 链式存储结构

